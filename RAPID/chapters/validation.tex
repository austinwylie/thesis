\chapter{Validation}
\label{validation}
In this last chapter, we summarize our validation of RAPID, showing that the system meets Chapter~\ref{requirements}'s critical requirements, correctly uses the concepts and technologies outlined in our Background, and is efficient enough for real use in the future.

We made two primary contributions: 1) guidelines for API developers---at this point, Francis---and external partners to validate our data model and overall system design and 2) performance testing results for common operations.

\section{Functionality}
RAPID includes a geospatial data model as well as file parsing and querying capabilities. We must, therefore, verify that RAPID's design meets its specification and that our codebase parses, stores, queries, and outputs geospatial data correctly. These are particularly prudent, as RAPID's entire purpose is to enable portability and interchangeability for \textit{external} partners and \textit{future} developers.

Our example setup between ABC Pipeline Co. and XYZ Operations is a relatively complete case study, showing real class instances and relationships. By showing the models and implementation patterns in Chapter~\ref{design} that support that needed functionality, it should be apparent that RAPID completely and successfully meets our system requirements from Chapter~\ref{requirements}.

Even though our model is, hopefully, convincing on its own, we worked with another student developer, Kishan Patel, to integrate a web application with RAPID for further validation. We call this software \textit{RAPID UI}, which visualizes spatial entities and our organization of data (Features in DataLayers, DataLayers grouped into GeoViews).

Our peer developer, Patel, had to become acquainted with basic geospatial concepts and client-side libraries, but our contributions to RAPID were significant and successful enough that he was able to create a sensible UI using our most important API calls. Second, being able to visualize our data---both geographic geometries and accompanying properties---we literally see that data makes it through RAPID, from beginning to end, as expected. As an additional nicety, we share and visualize several datasets with RAPID UI that were recently recommended by pipeline operating partners.

Francis describes our work with Patel in-depth---she worked with him to design and fully test REST calls---but please see the short following summary, which outlines our expectations and findings for RAPID UI (focusing on the data model's role)~\cite{Francis}.

\begin{itemize}
\item A primary goal in researching GIS standards and technologies was to ensure RAPID operates as expected when handling (rather finicky) geospatial data. Therefore, we set up several sample DataLayers (from GeoJSON and Shapefiles) for RAPID UI to attempt retrieving and visualizing. In particular, we made our goal that he require as little custom logic as possible---relying instead upon pre-built utilities.

Patel and Francis ensured RAPID UI could properly request data and handle GeoJSON responses through the API (using common HTTP libraries in Python and JavaScript). After RAPID UI fetches standardized geospatial files, using particular GIS libraries \textit{should and does} let the application parse and visualize data in one step.

\item Showing relationships between GeoViews, DataLayers, and Features.

\end{itemize}

\section{Performance}
The previous section shows that, given our data model and business logic, RAPID operates properly; we now use this section to highlight our core data model's performance, showing that it's an efficient base for future additions. We point out specific interface actions from earlier that typify DSS work and compare their runtimes.

\subsection{Setup and results}
\textit{[Finish this section.]}
% db_index on off.

small, medium, large
points, polygons
Specific features
DataLayer lookup
GeoView lookup


\subsection{Unit testing discussion}
% All of these components could be validated with a thorough unit test suite, using these recommendations. On the back end, RAPID uses the Django web framework, which utilizes Python's standard library testing module, \texttt{unittest}~\cite{DjangoTesting}. Once each necessary data field is accounted for in each possible input and output format, exhaustive unit tests can ensure that each field in one format can be converted to the corresponding field in every other format.

% \begin{itemize}
% \item Writable and parseable digital format like GeoJSON or Shapefile.
% \item In-memory objects.
% \item WKT or GeoJSON---abstract text formats for geospatial features.
% \item Abstract data added to and retrieved from PostGIS.
% \end{itemize}

% Data can move linearly up and down that list; each of those steps and transitions can also be viewed as a data integrity checkpoint that deserves a unit test. For instance, a Polygon made up of bordering points (0, 0), (0, 10), and (10, 0) still needs to have the same meaning---a triangle with those three points---no matter where its format or location. GeoJSON files and Shapefiles, Python objects, WKT or GeoJSON notation, and PostGIS data structures can all be inspected to ensure that the same data is contained in each. If it isn't, the data was misshaped somewhere along the line that can be traced.